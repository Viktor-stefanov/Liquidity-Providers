{
  "language": "Solidity",
  "sources": {
    "contracts/Diamond.sol": {
      "content": "// SPDX-License-Identifier: No-License\npragma solidity 0.8.17;\n\nimport {LibDiamond} from \"./libraries/LibDiamond.sol\";\nimport {IDiamondCut} from \"./interfaces/IDiamondCut.sol\";\nimport {IDiamondLoupe} from \"./interfaces/IDiamondLoupe.sol\";\nimport {IERC165} from \"./interfaces/IERC165.sol\";\nimport {IERC173} from \"./interfaces/IERC173.sol\";\n\ncontract Diamond {\n    struct DiamondArgs {\n        address owner;\n        address init;\n        bytes initCalldata;\n    }\n\n    constructor(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        DiamondArgs memory _args\n    ) payable {\n        LibDiamond.setContractOwner(_args.owner);\n        LibDiamond.diamondCut(_diamondCut, _args.init, _args.initCalldata);\n    }\n\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n        address facet = ds.facet[msg.sig].facetAddress;\n        require(facet != address(0), \"Function not found.\");\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), facet, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n            switch result\n            case 0 {\n                revert(ptr, size)\n            }\n            default {\n                return(ptr, size)\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: No-License\npragma solidity 0.8.17;\n\nimport \"../interfaces/IDiamondCut.sol\";\nimport \"../interfaces/IDiamond.sol\";\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"diamonds.standart.diamond.storage\");\n\n    struct Facet {\n        address facetAddress;\n        uint16 selectorPosition;\n    }\n\n    struct DiamondStorage {\n        address contractOwner;\n        mapping(bytes4 => Facet) facet;\n        bytes4[] selectors;\n        mapping(bytes4 => uint256) selectorToIndex;\n    }\n\n    event OwnershipTransferred(\n        address indexed prevOwner,\n        address indexed newOwner\n    );\n\n    event DiamondCut(\n        IDiamondCut.FacetCut[] _diamondCut,\n        address _init,\n        bytes _callData\n    );\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address prevOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(prevOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        if (msg.sender != diamondStorage().contractOwner) revert();\n    }\n\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (\n            uint256 facetIndex;\n            facetIndex < _diamondCut.length;\n            facetIndex++\n        ) {\n            bytes4[] memory functionSelectors = _diamondCut[facetIndex]\n                .functionSelectors;\n            address facetAddress = _diamondCut[facetIndex].facetAddress;\n            if (functionSelectors.length == 0) revert();\n\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamond.FacetCutAction.Add)\n                addFunctions(facetAddress, functionSelectors);\n            else if (action == IDiamond.FacetCutAction.Replace)\n                replaceFunctions(facetAddress, functionSelectors);\n            else if (action == IDiamond.FacetCutAction.Remove)\n                removeFunctions(facetAddress, functionSelectors);\n            else revert();\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        if (_facetAddress == address(0)) revert();\n        enforceHasContractCode(\n            _facetAddress,\n            \"LibDIamondCut: Add facet has no code.\"\n        );\n        DiamondStorage storage ds = diamondStorage();\n        uint16 selectorCount = uint16(_functionSelectors.length);\n        for (uint256 index = 0; index < _functionSelectors.length; index++) {\n            bytes4 selector = _functionSelectors[index];\n            address oldFacetAddress = ds.facet[selector].facetAddress;\n            if (oldFacetAddress != address(0)) revert(); // prohibit adding already existing function\n            ds.facet[selector] = Facet(_facetAddress, selectorCount);\n            ds.selectors.push(selector);\n            ds.selectorToIndex[selector] = ++selectorCount;\n        }\n    }\n\n    function replaceFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(_facetAddress != address(0), \"\");\n        enforceHasContractCode(\n            _facetAddress,\n            \"LibDiamondCut: Replace facet has no code.\"\n        );\n        DiamondStorage storage ds = diamondStorage();\n        for (\n            uint256 selectorIndex = 0;\n            selectorIndex < _functionSelectors.length;\n            selectorIndex++\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.facet[selector].facetAddress;\n            require(oldFacetAddress != address(this), \"Function is immutable.\");\n            require(\n                oldFacetAddress != _facetAddress,\n                \"Can't replace facet with same facet.\"\n            );\n            require(\n                oldFacetAddress != address(0),\n                \"Cannot have address 0 facet.\"\n            );\n            ds.facet[selector].facetAddress = _facetAddress;\n        }\n    }\n\n    function removeFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(_facetAddress != address(0), \"\");\n        enforceHasContractCode(\n            _facetAddress,\n            \"LibDiamondCut: Replace facet has no code.\"\n        );\n        DiamondStorage storage ds = diamondStorage();\n        uint256 selectorCount = uint16(_functionSelectors.length);\n        for (\n            uint256 selectorIndex = 0;\n            selectorIndex < _functionSelectors.length;\n            selectorIndex++\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            Facet memory oldFacet = ds.facet[selector];\n            require(oldFacet.facetAddress != address(0), \"No facet to remove.\");\n            require(\n                oldFacet.facetAddress == address(this),\n                \"Can't remove an immutable function.\"\n            );\n            /// @TODO: decypher the next 6 lines of code\n            if (oldFacet.selectorPosition != --selectorCount) {\n                bytes4 lastSelector = ds.selectors[selectorCount];\n                ds.selectors[oldFacet.selectorPosition] = lastSelector;\n                ds.facet[lastSelector].selectorPosition = oldFacet\n                    .selectorPosition;\n            }\n            ds.selectors.pop();\n            delete ds.facet[selector];\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata)\n        internal\n    {\n        // check if _init exists and has code and delegate the calldata\n        if (_init == address(0)) return;\n        enforceHasContractCode(\n            _init,\n            \"LibDIamondCut: _init address has no code\"\n        );\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else revert();\n        }\n    }\n\n    function enforceHasContractCode(\n        address _contract,\n        string memory _errorMessage\n    ) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize != 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: No-License\npragma solidity 0.8.17;\n\nimport \"./IDiamond.sol\";\n\ninterface IDiamondCut is IDiamond {\n    function diamond(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n}\n"
    },
    "contracts/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: No-License\npragma solidity 0.8.17;\n\ninterface IDiamondLoupe {\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    function facets() external view returns (Facet[] memory facets_);\n\n    function facetFunctionSelectors(address _facet)\n        external\n        view\n        returns (bytes4[] memory facetFunctionSelectors_);\n\n    function facetAddresses(address _facet)\n        external\n        view\n        returns (address[] memory facetAddresses_);\n\n    function facetAddress(bytes4 _functionSelector)\n        external\n        view\n        returns (address facetAddress_);\n}\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: No-License\npragma solidity 0.8.17;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: No-License\npragma solidity 0.8.17;\n\ninterface IERC173 {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    function owner() external view returns (address owner_);\n\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/interfaces/IDiamond.sol": {
      "content": "// SPDX-License-Identifier: No-License\npragma solidity 0.8.17;\n\ninterface IDiamond {\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}